<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled 3D Particles</title>
    <style>
        /* Modern Reset & Base Styles */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050505; 
            font-family: 'Inter', 'Segoe UI', sans-serif;
            user-select: none;
        }

        /* The hidden video element for MediaPipe */
        #input_video { display: none; }

        /* Floating Glassmorphism UI */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 260px;
            padding: 20px;
            background: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            color: white;
            z-index: 100;
            transition: transform 0.3s ease;
        }

        h1 {
            font-size: 1.1rem;
            margin: 0 0 15px 0;
            font-weight: 600;
            background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .control-section { margin-bottom: 20px; }
        .label { font-size: 0.8rem; color: #aaa; margin-bottom: 8px; display: block; }

        /* Grid for Shape Buttons */
        .shape-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        button:hover { background: rgba(255, 255, 255, 0.15); }
        
        button.active {
            background: rgba(0, 210, 255, 0.2);
            border-color: #00d2ff;
            color: #00d2ff;
            font-weight: bold;
        }

        /* Color Picker Styling */
        .color-wrapper {
            position: relative;
            height: 40px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
        }
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 150%; 
            height: 150%;
            position: absolute;
            top: -25%; left: -25%;
            cursor: pointer;
            background: none;
        }

        /* Status & Instructions */
        #status-bar {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 90;
        }
        
        .status-pill {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            padding: 8px 16px;
            border-radius: 20px;
            color: #888;
            font-size: 0.9rem;
            border: 1px solid rgba(255,255,255,0.1);
            display: inline-block;
            transition: color 0.3s;
        }
        
        .status-active { color: #00ff88; border-color: rgba(0, 255, 136, 0.3); }

        /* Loader */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 200;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            color: white;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333;
            border-top: 4px solid #00d2ff; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div class="spinner"></div>
        <div>Initializing Vision AI...</div>
        <div style="font-size: 0.8rem; color: #666; margin-top: 5px;">Please allow camera access</div>
    </div>

    <!-- Hidden Video for Processing -->
    <video id="input_video"></video>

    <!-- Main UI -->
    <div id="ui-panel">
        <h1>Particle Shaper</h1>
        
        <div class="control-section">
            <span class="label">SELECT TEMPLATE</span>
            <div class="shape-grid">
                <button onclick="changeShape('heart')" id="btn-heart" class="active">Heart</button>
                <button onclick="changeShape('flower')" id="btn-flower">Flower</button>
                <button onclick="changeShape('saturn')" id="btn-saturn">Saturn</button>
                <button onclick="changeShape('buddha')" id="btn-buddha">Buddha</button>
                <button onclick="changeShape('fireworks')" id="btn-fireworks">Fireworks</button>
                <button onclick="changeShape('sphere')" id="btn-sphere">Sphere</button>
            </div>
        </div>

        <div class="control-section">
            <span class="label">PARTICLE COLOR</span>
            <div class="color-wrapper">
                <input type="color" id="colorPicker" value="#00d2ff">
            </div>
        </div>

        <div style="font-size: 0.75rem; color: #888; line-height: 1.5; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px;">
            <strong style="color:white;">How to control:</strong><br>
            Show <b>both hands</b> to the camera.<br>
            ↔️ Move apart to <b>Expand</b><br>
            ➡️⬅️ Move closer to <b>Shrink</b>
        </div>
    </div>

    <div id="status-bar">
        <div id="status-text" class="status-pill">Waiting for hands...</div>
    </div>

    <script>
        /**
         * 1. THREE.JS SETUP
         */
        const scene = new THREE.Scene();
        // Add subtle fog for depth
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 35;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        /**
         * 2. PARTICLE SYSTEM
         */
        const PARTICLE_COUNT = 15000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        
        // Initial random positions
        for(let i = 0; i < PARTICLE_COUNT * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 50;
            targetPositions[i] = positions[i];
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Create a circular glow texture programmatically
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        const material = new THREE.PointsMaterial({
            size: 0.5,
            map: createGlowTexture(),
            transparent: true,
            opacity: 0.8,
            color: new THREE.Color('#00d2ff'),
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        /**
         * 3. SHAPE GENERATION LOGIC
         */
        function getShapeCoordinates(type) {
            const arr = [];
            const r = Math.random;
            
            for(let i = 0; i < PARTICLE_COUNT; i++) {
                let x = 0, y = 0, z = 0;

                if (type === 'heart') {
                    // 3D Heart
                    const t = r() * Math.PI * 2; 
                    const phi = r() * Math.PI;
                    // Base parametric heart
                    x = 16 * Math.pow(Math.sin(t), 3);
                    y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    // Add thickness
                    z = (r() - 0.5) * 5;
                    // Randomize slightly for volume
                    x += (r()-0.5); y += (r()-0.5);
                } 
                else if (type === 'sphere') {
                    const theta = r() * Math.PI * 2;
                    const phi = Math.acos(2 * r() - 1);
                    const rad = 12;
                    x = rad * Math.sin(phi) * Math.cos(theta);
                    y = rad * Math.sin(phi) * Math.sin(theta);
                    z = rad * Math.cos(phi);
                }
                else if (type === 'saturn') {
                    if (i < PARTICLE_COUNT * 0.4) {
                        // Planet
                        const theta = r() * Math.PI * 2;
                        const phi = Math.acos(2 * r() - 1);
                        const rad = 6;
                        x = rad * Math.sin(phi) * Math.cos(theta);
                        y = rad * Math.sin(phi) * Math.sin(theta);
                        z = rad * Math.cos(phi);
                    } else {
                        // Rings
                        const angle = r() * Math.PI * 2;
                        const rad = 9 + r() * 8; // Ring width
                        x = Math.cos(angle) * rad;
                        z = Math.sin(angle) * rad;
                        y = (r() - 0.5) * 0.5; // Flatness
                        // Tilt
                        const tilt = 0.5;
                        const ty = y * Math.cos(tilt) - z * Math.sin(tilt);
                        const tz = y * Math.sin(tilt) + z * Math.cos(tilt);
                        y = ty; z = tz;
                    }
                }
                else if (type === 'flower') {
                    // 3D Rose
                    const theta = r() * Math.PI * 2;
                    const k = 5; // Petals
                    const rad = 12 * Math.cos(k * theta) + 3;
                    x = rad * Math.cos(theta);
                    y = rad * Math.sin(theta);
                    z = (r()-0.5) * 4 + (rad/3) * Math.sin(theta*5); // Petal depth
                }
                else if (type === 'fireworks') {
                    // Starburst
                    const theta = r() * Math.PI * 2;
                    const phi = Math.acos(2 * r() - 1);
                    const rad = Math.pow(r(), 0.5) * 20; // Concentrate slightly towards center
                    x = rad * Math.sin(phi) * Math.cos(theta);
                    y = rad * Math.sin(phi) * Math.sin(theta);
                    z = rad * Math.cos(phi);
                }
                else if (type === 'buddha') {
                    // Procedural Sitting Figure
                    const val = r();
                    let rad = 0;
                    if (val < 0.25) { // Head
                        const theta = r() * Math.PI * 2;
                        const phi = Math.acos(2 * r() - 1);
                        rad = 2.5;
                        x = rad * Math.sin(phi) * Math.cos(theta);
                        y = rad * Math.sin(phi) * Math.sin(theta) + 7;
                        z = rad * Math.cos(phi);
                    } else if (val < 0.65) { // Body
                        const theta = r() * Math.PI * 2;
                        const phi = Math.acos(2 * r() - 1);
                        rad = 5;
                        x = rad * Math.sin(phi) * Math.cos(theta);
                        y = rad * Math.sin(phi) * Math.sin(theta) * 1.2; // Slightly elongated
                        z = rad * Math.cos(phi);
                    } else { // Base/Legs
                        const theta = r() * Math.PI * 2;
                        const phi = Math.acos(2 * r() - 1);
                        rad = 7;
                        x = rad * Math.sin(phi) * Math.cos(theta);
                        y = (rad * Math.sin(phi) * Math.sin(theta) * 0.4) - 4; // Flattened
                        z = rad * Math.cos(phi);
                    }
                }

                arr.push(x, y, z);
            }
            return arr;
        }

        // Handle Shape Switching
        function changeShape(type) {
            const coords = getShapeCoordinates(type);
            for(let i = 0; i < PARTICLE_COUNT * 3; i++) {
                targetPositions[i] = coords[i];
            }
            
            // UI Update
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${type}`).classList.add('active');
        }

        // Handle Color Switching
        document.getElementById('colorPicker').addEventListener('input', (e) => {
            material.color.set(e.target.value);
        });

        // Initialize default
        changeShape('heart');

        /**
         * 4. ANIMATION LOOP
         */
        let currentScale = 1;
        let targetScale = 1;

        function animate() {
            requestAnimationFrame(animate);

            // 1. Smoothly interpolate positions (Morphing effect)
            const posArray = particles.geometry.attributes.position.array;
            const morphSpeed = 0.04;
            
            for(let i = 0; i < PARTICLE_COUNT * 3; i++) {
                posArray[i] += (targetPositions[i] - posArray[i]) * morphSpeed;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // 2. Smoothly interpolate scale (Hand control)
            currentScale += (targetScale - currentScale) * 0.1;
            particles.scale.set(currentScale, currentScale, currentScale);

            // 3. Auto-rotation
            particles.rotation.y += 0.003;
            // particles.rotation.x += 0.001;

            renderer.render(scene, camera);
        }
        animate();

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        /**
         * 5. COMPUTER VISION (MediaPipe)
         */
        const videoElement = document.getElementById('input_video');
        const statusText = document.getElementById('status-text');
        const loader = document.getElementById('loader');

        function onHandsResults(results) {
            // Hide loader once we get first frame
            if (loader.style.display !== 'none') {
                loader.style.display = 'none';
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
                // Two hands detected
                statusText.innerText = "Hands Detected • Controlling Scale";
                statusText.classList.add('status-active');

                // Get Index Finger Tips (Landmark #8)
                const h1 = results.multiHandLandmarks[0][8];
                const h2 = results.multiHandLandmarks[1][8];

                // Calculate Euclidean distance between index fingers
                const dist = Math.sqrt(
                    Math.pow(h1.x - h2.x, 2) + 
                    Math.pow(h1.y - h2.y, 2)
                );

                // Mapping Logic:
                // Camera dist is usually 0.05 (touching) to 0.7 (wide)
                // We want scale to be approx 0.5 to 2.5
                const minInput = 0.05; 
                const maxInput = 0.5;
                const minScale = 0.4; 
                const maxScale = 2.5;

                // Normalize and clamp
                let normalized = (dist - minInput) / (maxInput - minInput);
                normalized = Math.max(0, Math.min(1, normalized));

                // Set global target for the animation loop
                targetScale = minScale + (normalized * (maxScale - minScale));

            } else {
                // Less than 2 hands
                statusText.innerText = "Show both hands to control scale";
                statusText.classList.remove('status-active');
                targetScale = 1; // Reset to default
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onHandsResults);

        // Start Camera
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        
        cameraUtils.start();

    </script>
</body>
</html>