<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gesture Particles 3D - Fixed</title>
    <style>
        :root {
            --glass-bg: rgba(20, 20, 20, 0.6);
            --glass-border: rgba(255, 255, 255, 0.15);
            --accent: #00f3ff;
            --text-main: #ffffff;
            --text-sub: #aaaaaa;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Inter', sans-serif;
            color: var(--text-main);
            overscroll-behavior: none; 
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #video-input { display: none; }

        /* åº•éƒ¨ UI é¢æ¿ */
        #ui-layer {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            width: 85vw;
            max-width: 400px;
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 16px;
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: opacity 0.3s;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--glass-border);
            padding-bottom: 8px;
            margin-bottom: 4px;
        }

        h1 { font-size: 1rem; margin: 0; font-weight: 600; display: flex; align-items: center; }

        .status-indicator {
            width: 8px; height: 8px; border-radius: 50%;
            background-color: #555; margin-right: 8px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            transition: 0.3s;
        }
        .status-indicator.active { background-color: #00ff88; box-shadow: 0 0 8px #00ff88; }
        .status-indicator.busy { background-color: #00f3ff; box-shadow: 0 0 8px #00f3ff; }

        .info-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 0.85rem;
        }
        .info-item {
            background: rgba(255,255,255,0.05); padding: 6px 10px;
            border-radius: 8px; display: flex; flex-direction: column;
        }
        .label { font-size: 0.7rem; color: var(--text-sub); margin-bottom: 2px; }
        .value { font-family: monospace; color: var(--accent); font-weight: bold;}

        .instruction-mini {
            font-size: 0.75rem; color: var(--text-sub); text-align: center; margin-top: 5px; opacity: 0.8;
        }

        #loading {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            z-index: 20; text-align: center; font-weight: 300;
            background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; pointer-events: none;
        }
        
        /* è¦–è¦ºåé¥‹å‹•ç•« */
        @keyframes flash {
            0% { background-color: rgba(255,255,255,0.05); }
            50% { background-color: rgba(255, 0, 100, 0.3); }
            100% { background-color: rgba(255,255,255,0.05); }
        }
        .color-changed { animation: flash 0.3s ease-out; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">ç³»çµ±åˆå§‹åŒ–ä¸­...<br><span style="font-size:0.8rem; opacity:0.7">è«‹å…è¨±æ”å½±æ©Ÿæ¬Šé™</span></div>

    <div id="ui-layer">
        <div class="header">
            <h1><span class="status-indicator" id="status-dot"></span>æ§åˆ¶å°</h1>
            <div style="font-size: 0.7rem; opacity: 0.5">V2.1 Fixed</div>
        </div>
        
        <div class="info-grid">
            <div class="info-item" id="gesture-box">
                <span class="label">æ‰‹å‹¢ (Gesture)</span>
                <span class="value" id="gesture-status">ç­‰å¾…ä¸­...</span>
            </div>
            <div class="info-item">
                <span class="label">å½¢ç‹€ (Shape)</span>
                <span class="value" id="shape-status">Random</span>
            </div>
        </div>

        <div class="instruction-mini">ğŸ– å¼µé–‹æ›å½¢ç‹€ Â· âœŠ æ¡æ‹³æ›è‰² Â· â†” å‰å¾Œç¸®æ”¾</div>
    </div>

    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>

<script>
    // --- 1. Three.js å ´æ™¯è¨­ç½® ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.003);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 35;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    const particleCount = 4500;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const targetPositions = new Float32Array(particleCount * 3);

    // åˆå§‹ä½ç½®èˆ‡é¡è‰²
    const tempColor = new THREE.Color();
    for (let i = 0; i < particleCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 60;
        targetPositions[i] = positions[i];
        
        // åˆå§‹è¨­ç‚ºé’è‰²ç³»
        tempColor.setHSL(0.5 + Math.random() * 0.1, 0.8, 0.5);
        colors[i] = tempColor.r;
        colors[i+1] = tempColor.g;
        colors[i+2] = tempColor.b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 0.4, // ç¨å¾®åŠ å¤§ç²’å­
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true,
        opacity: 0.8
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 2. å½¢ç‹€é‚è¼¯ ---
    const shapes = {
        heart: (i) => {
            const t = Math.random() * Math.PI * 2;
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            const z = (Math.random() - 0.5) * 6;
            return [x * 0.6, y * 0.6, z];
        },
        flower: (i) => {
            const spread = 0.6;
            const angle = 137.5 * (Math.PI / 180) * i;
            const r = spread * Math.sqrt(i);
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);
            const z = Math.sin(r * 0.4) * 8;
            return [x, y, z];
        },
        saturn: (i) => {
            const isRing = Math.random() > 0.5;
            if (isRing) {
                const angle = Math.random() * Math.PI * 2;
                const r = 14 + Math.random() * 6;
                return [r * Math.cos(angle), r * Math.sin(angle) * 0.15, r * Math.sin(angle) * 0.8];
            } else {
                const r = 9;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                return [r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)];
            }
        },
        buddha: (i) => {
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI * 2;
            const p = 2, q = 3;
            const r = 8 + Math.cos(q * v) * 2;
            const x = r * Math.cos(p * u);
            const y = r * Math.sin(p * u);
            const z = Math.sin(q * v) * 5 + (Math.random()-0.5)*2;
            return [x, y, z];
        },
        fireworks: (i) => {
            const r = Math.random() * 25;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            return [r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)];
        }
    };
    const shapeKeys = Object.keys(shapes);
    
    function setTargetShape(shapeName) {
        document.getElementById('shape-status').innerText = shapeName.toUpperCase();
        const generator = shapes[shapeName];
        for (let i = 0; i < particleCount; i++) {
            const [x, y, z] = generator(i);
            targetPositions[i * 3] = x;
            targetPositions[i * 3 + 1] = y;
            targetPositions[i * 3 + 2] = z;
        }
    }

    // --- ä¿®æ­£å¾Œçš„é¡è‰²è®Šæ›å‡½æ•¸ ---
    function changeColors() {
        // UI åé¥‹ï¼šè®“ä½¿ç”¨è€…çŸ¥é“é¡è‰²è§¸ç™¼äº†
        const infoBox = document.getElementById('gesture-box');
        infoBox.classList.remove('color-changed');
        void infoBox.offsetWidth; // è§¸ç™¼é‡ç¹ª
        infoBox.classList.add('color-changed');

        // éš¨æ©Ÿé¸ä¸€å€‹ä¸»è‰²èª¿ (Hue: 0~1)
        const mainHue = Math.random(); 
        const isMultiColor = Math.random() > 0.8; // 20% æ©Ÿç‡è®Šæˆå½©è‰²

        const colorHelper = new THREE.Color();
        const attr = geometry.attributes.color;

        for (let i = 0; i < particleCount; i++) {
            if (isMultiColor) {
                // å…¨å½©æ¨¡å¼
                colorHelper.setHSL(Math.random(), 1.0, 0.6);
            } else {
                // å–®è‰²èª¿æ¨¡å¼ (å¸¶æœ‰å¾®å°è®ŠåŒ–)
                // Saturation 0.8~1.0, Lightness 0.4~0.8
                colorHelper.setHSL(mainHue + (Math.random()-0.5)*0.1, 0.9, 0.5 + Math.random()*0.3);
            }
            
            attr.setXYZ(i, colorHelper.r, colorHelper.g, colorHelper.b);
        }
        attr.needsUpdate = true;
    }

    setTargetShape('fireworks');

    // --- 3. MediaPipe æ‰‹å‹¢è™•ç† ---
    const videoElement = document.getElementById('video-input');
    const statusDot = document.getElementById('status-dot');
    const gestureTxt = document.getElementById('gesture-status');
    
    let handScale = 1.0;
    let gestureDebounce = 0;
    let lastGesture = 'none';

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            statusDot.classList.add('busy');
            statusDot.classList.remove('active');

            const lm = results.multiHandLandmarks[0];
            
            // 1. è¨ˆç®—æ‰‹æŒå¤§å° (ç”¨æ–¼è·é›¢)
            const wrist = lm[0];
            const middleBase = lm[9];
            const palmSize = Math.sqrt(Math.pow(wrist.x - middleBase.x, 2) + Math.pow(wrist.y - middleBase.y, 2));
            
            // è·é›¢ç¸®æ”¾æ§åˆ¶
            const targetScale = 0.5 + (palmSize * 6);
            handScale += (targetScale - handScale) * 0.1;

            // 2. è¨ˆç®—æ‰‹æŒ‡é–‹åˆç¨‹åº¦ (åˆ¤å®šå„ªåŒ–)
            const tips = [8, 12, 16, 20]; // æŒ‡å°–
            const mcp = [5, 9, 13, 17];   // æŒ‡æ ¹é—œç¯€
            
            let openScore = 0;
            // æ¯”è¼ƒæŒ‡å°–èˆ‡æŒ‡æ ¹åˆ°æ‰‹è…•çš„è·é›¢
            // å¦‚æœæŒ‡å°–è·é›¢æ‰‹è…• æ¯” æŒ‡æ ¹è·é›¢æ‰‹è…• è¿‘ -> å½æ›²
            for(let i=0; i<4; i++) {
                const tipToWrist = Math.sqrt(Math.pow(lm[tips[i]].x - wrist.x, 2) + Math.pow(lm[tips[i]].y - wrist.y, 2));
                const mcpToWrist = Math.sqrt(Math.pow(lm[mcp[i]].x - wrist.x, 2) + Math.pow(lm[mcp[i]].y - wrist.y, 2));
                
                // å¦‚æœæŒ‡å°–æ¯”æŒ‡æ ¹é‚„é  1.2 å€ä»¥ä¸Šï¼Œç®—å¼µé–‹
                if (tipToWrist > mcpToWrist * 1.3) {
                    openScore++;
                }
            }

            // åˆ¤å®šé‚è¼¯
            let currentGesture = 'neutral';
            
            // å¦‚æœè‡³å°‘ 3 æ ¹æ‰‹æŒ‡æ˜¯ç›´çš„ -> Open
            if (openScore >= 3) {
                currentGesture = 'open';
            } 
            // å¦‚æœæ²’æœ‰æ‰‹æŒ‡æ˜¯ç›´çš„ï¼Œä¸”æ‰‹æŒ‡å¾ˆé›†ä¸­ -> Closed
            // ä½¿ç”¨åŸæœ¬çš„å¹³å‡è·é›¢æ³•è¼”åŠ©åˆ¤å®šæ¡æ‹³
            else {
                 let avgTipDist = 0;
                 tips.forEach(i => {
                    avgTipDist += Math.sqrt(Math.pow(lm[i].x - lm[0].x, 2) + Math.pow(lm[i].y - lm[0].y, 2));
                 });
                 avgTipDist /= 4;
                 const ratio = avgTipDist / palmSize;

                 // ä¿®æ­£é€™è£¡ï¼šå°‡é–¾å€¼æ”¾å¯¬åˆ° 1.0 (åŸæœ¬æ˜¯ 0.85)
                 if (ratio < 1.0) {
                     currentGesture = 'closed';
                 }
            }

            // é¡¯ç¤ºç‹€æ…‹
            let displayTxt = "NEUTRAL";
            if(currentGesture === 'open') displayTxt = "OPEN (å¼µé–‹)";
            if(currentGesture === 'closed') displayTxt = "CLOSED (æ¡æ‹³)";
            gestureTxt.innerText = displayTxt;
            
            // è§¸ç™¼äº‹ä»¶ (é˜²æŠ–å‹• 500ms)
            const now = Date.now();
            if (now - gestureDebounce > 500) {
                if (currentGesture === 'open' && lastGesture !== 'open') {
                    const next = shapeKeys[Math.floor(Math.random() * shapeKeys.length)];
                    setTargetShape(next);
                    gestureDebounce = now;
                } 
                else if (currentGesture === 'closed' && lastGesture !== 'closed') {
                    // é€™è£¡è§¸ç™¼é¡è‰²
                    changeColors();
                    gestureDebounce = now;
                }
            }
            lastGesture = currentGesture;

        } else {
            statusDot.classList.add('active');
            statusDot.classList.remove('busy');
            gestureTxt.innerText = "NO HAND";
            handScale += (1.0 - handScale) * 0.05;
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640,
        height: 480,
        facingMode: 'user'
    });
    cameraUtils.start();

    // --- 4. å‹•ç•«è¿´åœˆ ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        const positions = geometry.attributes.position.array;

        for (let i = 0; i < particleCount; i++) {
            const idx = i * 3;
            positions[idx] += (targetPositions[idx] - positions[idx]) * 0.08; // åŠ å¿«ä¸€é»è®Šå½¢é€Ÿåº¦
            positions[idx+1] += (targetPositions[idx+1] - positions[idx+1]) * 0.08;
            positions[idx+2] += (targetPositions[idx+2] - positions[idx+2]) * 0.08;
            positions[idx+1] += Math.sin(time * 2 + positions[idx]) * 0.01;
        }
        geometry.attributes.position.needsUpdate = true;

        particles.rotation.y = time * 0.15;
        particles.scale.setScalar(handScale);
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>