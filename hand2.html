<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI æ‰‹å‹¢äº’å‹•ç²’å­ç³»çµ±</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Microsoft JhengHei', sans-serif; user-select: none; }
        #input_video { display: none; }
        
        /* ç‹€æ…‹åˆ— */
        #status-bar {
            position: absolute; bottom: 40px; width: 100%; text-align: center; pointer-events: none; z-index: 90;
            display: flex; flex-direction: column; align-items: center; gap: 10px;
        }
        .status-pill {
            background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            padding: 10px 24px; border-radius: 30px; color: rgba(255, 255, 255, 0.8); font-size: 1rem;
            border: 1px solid rgba(255,255,255,0.15); transition: all 0.3s ease;
        }

        /* è®€å–ç•«é¢ */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 200; display: flex; flex-direction: column;
            align-items: center; justify-content: center; color: white; transition: opacity 0.5s;
        }
        .spinner {
            width: 50px; height: 50px; border: 4px solid #333; border-top: 4px solid #00d2ff;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* éŒ¯èª¤è¨Šæ¯ */
        #error-log {
            display: none; margin-top: 20px; color: #ff6b6b; font-size: 0.8rem; background: rgba(50,0,0,0.5); padding: 10px; border-radius: 5px;
        }

        .instruction {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.4); font-size: 0.9rem; text-align: center; z-index: 50;
        }
    </style>

    <!-- 1. è¼‰å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- 2. è¼‰å…¥ MediaPipe (é–å®šç‰ˆæœ¬ 0.4.1646424915 ä»¥ç¢ºä¿ç©©å®š) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.6.1629159505/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <h3>æ­£åœ¨å•Ÿå‹•è¦–è¦º AI...</h3>
        <p>è«‹å…è¨±æ”å½±æ©Ÿæ¬Šé™</p>
        <div id="error-log"></div>
    </div>

    <div class="instruction">å½¢ç‹€æ¯ 3 ç§’åˆ‡æ› | âœŠ æ¡æ‹³æ›è‰² | ğŸ‘ é›™æ‰‹ç¸®æ”¾</div>
    <video id="input_video" playsinline></video>
    
    <div id="status-bar">
        <div id="shape-name" class="status-pill">è¼‰å…¥æ¨¡å‹ä¸­...</div>
        <div id="action-feedback" class="status-pill" style="opacity:0; transform: scale(0.8);">æ›è‰²ï¼</div>
    </div>

    <script>
        // é™¤éŒ¯å·¥å…·
        function logError(msg) {
            console.error(msg);
            const log = document.getElementById('error-log');
            log.style.display = 'block';
            log.innerText = "éŒ¯èª¤: " + msg;
        }

        // --- Three.js ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 35;
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const PARTICLE_COUNT = 15000;
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        for(let i=0; i<PARTICLE_COUNT*3; i++) {
            positions[i] = (Math.random()-0.5)*50;
            targetPositions[i] = positions[i];
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const canvas = document.createElement('canvas'); canvas.width=32; canvas.height=32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16,16,0,16,16,16);
        grad.addColorStop(0,'rgba(255,255,255,1)'); grad.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
        const texture = new THREE.Texture(canvas); texture.needsUpdate = true;

        const material = new THREE.PointsMaterial({
            size: 0.6, map: texture, transparent: true, opacity: 0.8,
            color: new THREE.Color(0x00d2ff), blending: THREE.AdditiveBlending, depthWrite: false
        });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // å½¢ç‹€é‚è¼¯
        function getShape(type) {
            const arr=[]; const r=Math.random;
            for(let i=0; i<PARTICLE_COUNT; i++){
                let x=0,y=0,z=0;
                if(type==='heart'){
                    let t=r()*Math.PI*2; x=16*Math.pow(Math.sin(t),3);
                    y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
                    z=(r()-0.5)*5; x+=(r()-0.5); y+=(r()-0.5);
                } else if(type==='sphere'){
                    let th=r()*Math.PI*2, ph=Math.acos(2*r()-1);
                    x=12*Math.sin(ph)*Math.cos(th); y=12*Math.sin(ph)*Math.sin(th); z=12*Math.cos(ph);
                } else if(type==='saturn'){
                    if(i<PARTICLE_COUNT*0.4){
                        let th=r()*Math.PI*2, ph=Math.acos(2*r()-1);
                        x=6*Math.sin(ph)*Math.cos(th); y=6*Math.sin(ph)*Math.sin(th); z=6*Math.cos(ph);
                    } else {
                        let a=r()*Math.PI*2, d=9+r()*8;
                        x=Math.cos(a)*d; z=Math.sin(a)*d; y=(r()-0.5)*0.5;
                        let ty=y*Math.cos(0.5)-z*Math.sin(0.5); z=y*Math.sin(0.5)+z*Math.cos(0.5); y=ty;
                    }
                } else { // é è¨­ fireworks
                    let th=r()*Math.PI*2, ph=Math.acos(2*r()-1), d=Math.pow(r(),0.5)*20;
                    x=d*Math.sin(ph)*Math.cos(th); y=d*Math.sin(ph)*Math.sin(th); z=d*Math.cos(ph);
                }
                arr.push(x,y,z);
            }
            return arr;
        }

        const shapes = ['heart','sphere','saturn','fireworks'];
        let shapeIdx=0;
        function updateShape() {
            const type = shapes[shapeIdx];
            document.getElementById('shape-name').innerText = "å½¢ç‹€: " + type;
            const coords = getShape(type);
            for(let i=0; i<PARTICLE_COUNT*3; i++) targetPositions[i] = coords[i];
            shapeIdx = (shapeIdx+1)%shapes.length;
        }
        updateShape();
        setInterval(updateShape, 3000);

        let currentScale=1, targetScale=1;
        function animate() {
            requestAnimationFrame(animate);
            const pos = particles.geometry.attributes.position.array;
            for(let i=0; i<PARTICLE_COUNT*3; i++) pos[i] += (targetPositions[i]-pos[i])*0.05;
            particles.geometry.attributes.position.needsUpdate = true;
            currentScale += (targetScale-currentScale)*0.1;
            particles.scale.set(currentScale, currentScale, currentScale);
            particles.rotation.y += 0.003;
            renderer.render(scene, camera);
        }
        animate();
        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        };

        // --- MediaPipe æ ¸å¿ƒä¿®å¾© ---
        const videoElement = document.getElementById('input_video');
        let isLoaded = false;
        let fistLocked = false;

        function onResults(results) {
            // åªè¦æˆåŠŸåŸ·è¡Œä¸€æ¬¡ï¼Œå°±éš±è—è®€å–ç•«é¢
            if(!isLoaded) {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(()=>{document.getElementById('loader').style.display='none'},500);
                isLoaded = true;
            }

            // é›™æ‰‹ç¸®æ”¾
            if (results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
                const h1 = results.multiHandLandmarks[0][8];
                const h2 = results.multiHandLandmarks[1][8];
                const d = Math.sqrt((h1.x-h2.x)**2 + (h1.y-h2.y)**2);
                let n = (d-0.05)/(0.6-0.05);
                targetScale = 0.3 + Math.max(0,Math.min(1,n))*(2.5-0.3);
            } else {
                targetScale = 1;
            }

            // æ¡æ‹³åµæ¸¬
            let fist = false;
            if(results.multiHandLandmarks) {
                for(const lm of results.multiHandLandmarks) {
                    const wrist = lm[0];
                    let folded = 0;
                    // æª¢æŸ¥å››æŒ‡æŒ‡å°–èˆ‡æŒ‡æ ¹è·é›¢
                    for(let i of [8,12,16,20]) {
                        const tip = lm[i], base = lm[i-3];
                        const dTip = (tip.x-wrist.x)**2+(tip.y-wrist.y)**2;
                        const dBase = (base.x-wrist.x)**2+(base.y-wrist.y)**2;
                        if(dTip < dBase * 1.2) folded++;
                    }
                    if(folded >= 4) fist = true;
                }
            }

            if(fist) {
                if(!fistLocked) {
                    material.color.setHSL(Math.random(), 1.0, 0.6);
                    const fb = document.getElementById('action-feedback');
                    fb.style.opacity = 1; fb.style.transform = 'scale(1)';
                    fb.style.color = '#' + material.color.getHexString();
                    setTimeout(()=>{ fb.style.opacity=0; fb.style.transform='scale(0.8)'; }, 1000);
                    fistLocked = true;
                }
            } else {
                fistLocked = false;
            }
        }

        // é€™è£¡ä¸€å®šè¦ä½¿ç”¨èˆ‡ script æ¨™ç±¤ä¸€è‡´çš„ CDN ç‰ˆæœ¬
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640, height: 480
        });
        
        // å•Ÿå‹•ä¸¦æ•æ‰éŒ¯èª¤
        cameraUtils.start()
            .then(() => console.log("æ”å½±æ©Ÿå•Ÿå‹•æˆåŠŸ"))
            .catch(e => logError("æ”å½±æ©Ÿå•Ÿå‹•å¤±æ•—: " + e.message));

    </script>
</body>
</html>