<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaPipe Gesture Recognition</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        
        .main-content {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .container {
            position: relative;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        #videoElement {
            border-radius: 8px;
            transform: scaleX(-1);
        }
        
        #canvasElement {
            position: absolute;
            top: 20px;
            left: 20px;
            border-radius: 8px;
            transform: scaleX(-1);
        }
        
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 300px;
        }
        
        .info {
            margin-top: 0;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .status {
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 5px;
            font-weight: bold;
        }
        
        .status.loading {
            background-color: #fff3cd;
            color: #856404;
        }
        
        .status.ready {
            background-color: #d4edda;
            color: #155724;
        }
        
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .controls {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
        }
        
        button:hover {
            background-color: #0056b3;
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .webcam-controls {
            margin-bottom: 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        button.start {
            background-color: #28a745;
        }
        
        button.start:hover {
            background-color: #218838;
        }
        
        button.stop {
            background-color: #dc3545;
        }
        
        button.stop:hover {
            background-color: #c82333;
        }
        
        .gesture-display {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            color: white;
            margin-bottom: 15px;
        }
        
        .gesture-name {
            font-size: 32px;
            font-weight: bold;
            margin: 10px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .gesture-emoji {
            font-size: 64px;
            margin: 10px 0;
        }
        
        .gesture-list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-top: 10px;
        }
        
        .gesture-item {
            padding: 8px;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .gesture-item.detected {
            background: #d4edda;
            border: 2px solid #28a745;
        }
        
        .gesture-emoji-small {
            font-size: 24px;
        }
    </style>
</head>
<body>
    <h1>MediaPipe Gesture Recognition</h1>
    
    <div id="status" class="status loading">Initializing MediaPipe...</div>
    
    <div class="main-content">
        <div class="container" id="videoContainer" style="display: none;">
            <video id="videoElement" width="640" height="480" autoplay></video>
            <canvas id="canvasElement" width="640" height="480"></canvas>
        </div>
        
        <div class="side-panel">
            <div class="info">
                <div class="webcam-controls">
                    <div class="button-group">
                        <button id="startButton" class="start" onclick="startCamera()">‚ñ∂ Start Camera</button>
                        <button id="stopButton" class="stop" onclick="stopCamera()" disabled>‚èπ Stop Camera</button>
                    </div>
                </div>
            </div>
            
            <div class="info">
                <div class="gesture-display">
                    <div class="gesture-emoji" id="gestureEmoji">üëã</div>
                    <div class="gesture-name" id="gestureName">No Gesture</div>
                </div>
            </div>
            
            <div class="info">
                <h3>Detection Info</h3>
                <p>Detected Hands: <span id="handCount">0</span></p>
                <p>FPS: <span id="fps">0</span></p>
                
                <div class="controls">
                    <button id="toggleButton" onclick="toggleDetection()" disabled>Pause Detection</button>
                    <button onclick="togglePoints()" disabled id="togglePointsButton">Hide Landmarks</button>
                    <button onclick="toggleBackground()" disabled id="toggleBgButton">Black Background</button>
                </div>
            </div>
            
            <div class="info">
                <h3>Supported Gestures</h3>
                <div class="gesture-list">
                    <div class="gesture-item" id="gesture-closed-fist">
                        <span class="gesture-emoji-small">‚úä</span>
                        <span>Closed Fist</span>
                    </div>
                    <div class="gesture-item" id="gesture-open-palm">
                        <span class="gesture-emoji-small">‚úã</span>
                        <span>Open Palm</span>
                    </div>
                    <div class="gesture-item" id="gesture-pointing-up">
                        <span class="gesture-emoji-small">‚òùÔ∏è</span>
                        <span>Pointing Up</span>
                    </div>
                    <div class="gesture-item" id="gesture-pointing-down">
                        <span class="gesture-emoji-small">üëá</span>
                        <span>Pointing Down</span>
                    </div>
                    <div class="gesture-item" id="gesture-thumb-down">
                        <span class="gesture-emoji-small">üëé</span>
                        <span>Thumb Down</span>
                    </div>
                    <div class="gesture-item" id="gesture-thumb-up">
                        <span class="gesture-emoji-small">üëç</span>
                        <span>Thumb Up</span>
                    </div>
                    <div class="gesture-item" id="gesture-victory">
                        <span class="gesture-emoji-small">‚úåÔ∏è</span>
                        <span>Victory</span>
                    </div>
                    <div class="gesture-item" id="gesture-i-love-you">
                        <span class="gesture-emoji-small">ü§ü</span>
                        <span>I Love You</span>
                    </div>
                </div>
            </div>
            
            <div class="info">
                <details style="margin-top: 0;">
                    <summary style="cursor: pointer; font-weight: bold;">About Gesture Recognition</summary>
                    <p style="margin-top: 10px;">
                        This system uses MediaPipe Hands to detect hand landmarks and recognize gestures.
                        It analyzes the position and angles of 21 hand keypoints to identify specific gestures.
                        Show your hand clearly to the camera for best results!
                    </p>
                </details>
            </div>
        </div>
    </div>

    <!-- Load MediaPipe libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        const videoElement = document.getElementById('videoElement');
        const canvasElement = document.getElementById('canvasElement');
        const canvasCtx = canvasElement.getContext('2d');
        const statusDiv = document.getElementById('status');
        const handCountSpan = document.getElementById('handCount');
        const fpsSpan = document.getElementById('fps');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const toggleButton = document.getElementById('toggleButton');
        const togglePointsButton = document.getElementById('togglePointsButton');
        const toggleBgButton = document.getElementById('toggleBgButton');
        const videoContainer = document.getElementById('videoContainer');
        const gestureNameDiv = document.getElementById('gestureName');
        const gestureEmojiDiv = document.getElementById('gestureEmoji');
        
        let isDetecting = true;
        let showPoints = true;
        let lastTime = Date.now();
        let frameCount = 0;
        let currentStream = null;
        let animationFrameId = null;
        let useBlackBackground = false;
        let currentGesture = 'None';

        // Gesture emoji mapping
        const gestureEmojis = {
            'Closed_Fist': '‚úä',
            'Open_Palm': '‚úã',
            'Pointing_Up': '‚òùÔ∏è',
            'Pointing_Down': 'üëá',
            'Thumb_Down': 'üëé',
            'Thumb_Up': 'üëç',
            'Victory': '‚úåÔ∏è',
            'ILoveYou': 'ü§ü',
            'None': 'üëã'
        };

        // Gesture name mapping
        const gestureNames = {
            'Closed_Fist': 'Closed Fist',
            'Open_Palm': 'Open Palm',
            'Pointing_Up': 'Pointing Up',
            'Pointing_Down': 'Pointing Down',
            'Thumb_Down': 'Thumb Down',
            'Thumb_Up': 'Thumb Up',
            'Victory': 'Victory',
            'ILoveYou': 'I Love You',
            'None': 'No Gesture'
        };

        // Initialize MediaPipe Hands
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        // Configure Hands parameters
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        // Process detection results
        hands.onResults(onResults);

        function onResults(results) {
            if (!isDetecting || !currentStream) return;
            
            // Clear canvas
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // Draw background
            if (useBlackBackground) {
                canvasCtx.fillStyle = '#000000';
                canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
            } else {
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            }
            
            if (results.multiHandLandmarks && results.multiHandedness) {
                handCountSpan.textContent = results.multiHandLandmarks.length;
                
                let detectedGesture = 'None';
                
                // Process each hand
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handedness = results.multiHandedness[i].label;
                    
                    // Recognize gesture
                    const gesture = recognizeGesture(landmarks, handedness);
                    if (gesture !== 'None') {
                        detectedGesture = gesture;
                    }
                    
                    if (showPoints) {
                        // Draw hand landmarks
                        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                        drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 3});
                    }
                }
                
                // Update gesture display
                updateGestureDisplay(detectedGesture);
            } else {
                handCountSpan.textContent = '0';
                updateGestureDisplay('None');
            }
            
            canvasCtx.restore();
            updateFPS();
        }

        // Recognize gesture based on hand landmarks
        function recognizeGesture(landmarks, handedness) {
            // Get key landmarks
            const wrist = landmarks[0];
            
            // Thumb landmarks
            const thumbCMC = landmarks[1];
            const thumbMCP = landmarks[2];
            const thumbIP = landmarks[3];
            const thumbTip = landmarks[4];
            
            // Index finger landmarks
            const indexMCP = landmarks[5];
            const indexPIP = landmarks[6];
            const indexDIP = landmarks[7];
            const indexTip = landmarks[8];
            
            // Middle finger landmarks
            const middleMCP = landmarks[9];
            const middlePIP = landmarks[10];
            const middleDIP = landmarks[11];
            const middleTip = landmarks[12];
            
            // Ring finger landmarks
            const ringMCP = landmarks[13];
            const ringPIP = landmarks[14];
            const ringDIP = landmarks[15];
            const ringTip = landmarks[16];
            
            // Pinky landmarks
            const pinkyMCP = landmarks[17];
            const pinkyPIP = landmarks[18];
            const pinkyDIP = landmarks[19];
            const pinkyTip = landmarks[20];
            
            // Calculate if each finger is extended - LOWERED THRESHOLD to 70%
            const isThumbExtended = isFingerExtended(thumbCMC, thumbMCP, thumbIP, thumbTip, 0.70);
            const isIndexExtended = isFingerExtended(indexMCP, indexPIP, indexDIP, indexTip, 0.70);
            const isMiddleExtended = isFingerExtended(middleMCP, middlePIP, middleDIP, middleTip, 0.70);
            const isRingExtended = isFingerExtended(ringMCP, ringPIP, ringDIP, ringTip, 0.70);
            const isPinkyExtended = isFingerExtended(pinkyMCP, pinkyPIP, pinkyDIP, pinkyTip, 0.70);
            
            // Alternative curl detection - check if fingertip is below PIP joint
            const isIndexCurled = indexTip.y > indexPIP.y + 0.02;
            const isMiddleCurled = middleTip.y > middlePIP.y + 0.02;
            const isRingCurled = ringTip.y > ringPIP.y + 0.02;
            const isPinkyCurled = pinkyTip.y > pinkyPIP.y + 0.02;
            
            // Improved thumb curl detection - use multiple methods
            const thumbTipToMCP = getDistance(thumbTip, thumbMCP);
            const thumbIPToMCP = getDistance(thumbIP, thumbMCP);
            const thumbTipToIP = getDistance(thumbTip, thumbIP);
            const thumbIPToCMC = getDistance(thumbIP, thumbCMC);
            
            // Thumb is curled if:
            // 1. Tip-to-MCP distance is small compared to IP-to-CMC
            // 2. OR tip is very close to IP (bent inward)
            const isThumbCurled = (thumbTipToMCP < thumbIPToCMC * 0.8) || (thumbTipToIP < thumbIPToCMC * 0.3);
            
            // Count extended fingers
            const extendedFingers = [isIndexExtended, isMiddleExtended, isRingExtended, isPinkyExtended];
            const extendedCount = extendedFingers.filter(x => x).length;
            
            // Count curled fingers
            const curledCount = [isIndexCurled, isMiddleCurled, isRingCurled, isPinkyCurled].filter(x => x).length;
            
            // Get palm center
            const palmCenterY = (wrist.y + indexMCP.y + middleMCP.y + ringMCP.y + pinkyMCP.y) / 5;
            
            // Check thumb orientation
            const thumbPointingUp = thumbTip.y < thumbMCP.y - 0.03;
            const thumbPointingDown = thumbTip.y > thumbMCP.y + 0.03;
            
            // CLOSED FIST - all fingers curled (use curl detection)
            // IMPORTANT: Check this BEFORE Thumb Up to avoid confusion
            if (curledCount >= 4 && isThumbCurled) {
                // Closed fist: thumb is curled AND not pointing significantly upward
                return 'Closed_Fist';
            }
            
            // Alternative check for closed fist - if all fingers are clearly not extended
            if (!isIndexExtended && !isMiddleExtended && !isRingExtended && !isPinkyExtended && !isThumbExtended) {
                return 'Closed_Fist';
            }
            
            // THUMB UP - thumb extended upward, other fingers curled
            // More strict conditions to avoid false positives with Closed Fist
            if (isThumbExtended && !isIndexExtended && !isMiddleExtended && !isRingExtended && !isPinkyExtended) {
                // Thumb must be clearly pointing up
                if (thumbPointingUp && thumbTip.y < wrist.y - 0.08) {
                    return 'Thumb_Up';
                }
            }
            
            // THUMB DOWN - thumb extended downward, other fingers curled
            // Check BEFORE Open Palm to avoid confusion
            if (isThumbExtended && thumbPointingDown) {
                // Make sure thumb is pointing down and most fingers are curled
                if (thumbTip.y > palmCenterY + 0.05) {
                    // Allow 1-2 fingers slightly extended but prefer curled
                    if (curledCount >= 2) {
                        return 'Thumb_Down';
                    }
                }
            }
            
            // POINTING UP - only index finger extended, pointing upward
            if (isIndexExtended && !isMiddleExtended && !isRingExtended && !isPinkyExtended) {
                // Make sure index is pointing up (tip above MCP)
                if (indexTip.y < indexMCP.y - 0.05) {
                    return 'Pointing_Up';
                }
            }
            
            // POINTING DOWN - only index finger extended, pointing downward
            if (isIndexExtended && !isMiddleExtended && !isRingExtended && !isPinkyExtended) {
                // Make sure index is pointing down (tip below MCP)
                if (indexTip.y > indexMCP.y + 0.05) {
                    return 'Pointing_Down';
                }
            }
            
            // VICTORY - index and middle fingers extended, others curled
            // RELAXED CONDITIONS
            if (isIndexExtended && isMiddleExtended && !isRingExtended && !isPinkyExtended) {
                // Check if fingers are somewhat separated
                const fingerDistance = getDistance2D(indexTip, middleTip);
                const baseDistance = getDistance2D(indexMCP, middleMCP);
                
                // LOWERED threshold from 1.5 to 1.2
                if (fingerDistance > baseDistance * 1.2 || 
                    (indexTip.y < indexMCP.y && middleTip.y < middleMCP.y)) {
                    return 'Victory';
                }
            }
            
            // I LOVE YOU - thumb, index, and pinky extended
            if (isThumbExtended && isIndexExtended && !isMiddleExtended && !isRingExtended && isPinkyExtended) {
                return 'ILoveYou';
            }
            
            // OPEN PALM - all 5 fingers extended
            // Check AFTER specific gestures to avoid false positives
            if (isThumbExtended && extendedCount >= 3) {
                // Make sure thumb is NOT pointing down (avoid Thumb Down confusion)
                if (!thumbPointingDown) {
                    return 'Open_Palm';
                }
            }
            
            return 'None';
        }

        // Check if a finger is extended using angle calculation with adjustable threshold
        function isFingerExtended(base, pip, dip, tip, threshold = 0.70) {
            // Calculate the distance from tip to base
            const tipToBase = getDistance(tip, base);
            
            // Calculate expected extended length (straight finger)
            const segment1 = getDistance(base, pip);
            const segment2 = getDistance(pip, dip);
            const segment3 = getDistance(dip, tip);
            const totalLength = segment1 + segment2 + segment3;
            
            // If tip-to-base distance is close to total length, finger is extended
            return tipToBase > totalLength * threshold;
        }

        // Calculate 2D distance (ignore Z) for better gesture recognition
        function getDistance2D(point1, point2) {
            const dx = point1.x - point2.x;
            const dy = point1.y - point2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Calculate distance between two points
        function getDistance(point1, point2) {
            const dx = point1.x - point2.x;
            const dy = point1.y - point2.y;
            const dz = (point1.z || 0) - (point2.z || 0);
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }

        // Update gesture display
        function updateGestureDisplay(gesture) {
            if (gesture !== currentGesture) {
                currentGesture = gesture;
                gestureNameDiv.textContent = gestureNames[gesture] || 'No Gesture';
                gestureEmojiDiv.textContent = gestureEmojis[gesture] || 'üëã';
                
                // Highlight detected gesture in list
                document.querySelectorAll('.gesture-item').forEach(item => {
                    item.classList.remove('detected');
                });
                
                if (gesture !== 'None') {
                    const gestureId = 'gesture-' + gesture.toLowerCase().replace('_', '-');
                    const element = document.getElementById(gestureId);
                    if (element) {
                        element.classList.add('detected');
                    }
                }
            }
        }

        // Update FPS
        function updateFPS() {
            frameCount++;
            const currentTime = Date.now();
            if (currentTime - lastTime >= 1000) {
                fpsSpan.textContent = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        // Start camera
        async function startCamera() {
            try {
                if (currentStream) {
                    stopCamera();
                }

                statusDiv.textContent = '‚è≥ Starting camera...';
                statusDiv.className = 'status loading';

                const constraints = {
                    video: {
                        width: 640,
                        height: 480,
                        facingMode: 'user'
                    }
                };

                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = currentStream;
                
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        resolve();
                    };
                });

                videoContainer.style.display = 'block';
                statusDiv.textContent = '‚úì Camera started. Initializing detection...';
                statusDiv.className = 'status ready';

                const processFrame = async () => {
                    if (currentStream && videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
                        await hands.send({image: videoElement});
                    }
                    animationFrameId = requestAnimationFrame(processFrame);
                };
                
                processFrame();
                
                statusDiv.textContent = '‚úì Detection active';
                statusDiv.className = 'status ready';
                startButton.disabled = true;
                stopButton.disabled = false;
                toggleButton.disabled = false;
                togglePointsButton.disabled = false;
                toggleBgButton.disabled = false;
                
            } catch (error) {
                console.error('Camera start failed:', error);
                
                let errorMessage = '‚úó Error: ';
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage += 'Camera permission denied. Please allow camera access and try again.';
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    errorMessage += 'Camera not found. Please check your camera connection.';
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    errorMessage += 'Camera is being used by another application.';
                } else if (error.name === 'OverconstrainedError') {
                    errorMessage += 'Camera does not support the required resolution.';
                } else if (error.name === 'SecurityError') {
                    errorMessage += 'Security restriction: Please use HTTPS or localhost.';
                } else {
                    errorMessage += error.message || 'Cannot access camera';
                }
                
                statusDiv.textContent = errorMessage;
                statusDiv.className = 'status error';
                showTroubleshootingInfo();
            }
        }

        // Stop camera
        function stopCamera() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
                videoElement.srcObject = null;
            }

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            videoContainer.style.display = 'none';

            statusDiv.textContent = '‚èπ Camera stopped';
            statusDiv.className = 'status loading';
            startButton.disabled = false;
            stopButton.disabled = true;
            toggleButton.disabled = true;
            togglePointsButton.disabled = true;
            toggleBgButton.disabled = true;
            handCountSpan.textContent = '0';
            fpsSpan.textContent = '0';
            updateGestureDisplay('None');
        }

        // Toggle detection
        function toggleDetection() {
            if (!currentStream) return;
            
            isDetecting = !isDetecting;
            
            if (isDetecting) {
                toggleButton.textContent = 'Pause Detection';
                statusDiv.textContent = '‚úì Detection active';
                statusDiv.className = 'status ready';
            } else {
                toggleButton.textContent = 'Resume Detection';
                statusDiv.textContent = '‚è∏ Detection paused';
                statusDiv.className = 'status loading';
            }
        }

        // Toggle landmarks display
        function togglePoints() {
            showPoints = !showPoints;
            togglePointsButton.textContent = showPoints ? 'Hide Landmarks' : 'Show Landmarks';
        }

        // Toggle background
        function toggleBackground() {
            useBlackBackground = !useBlackBackground;
            toggleBgButton.textContent = useBlackBackground ? 'Video Background' : 'Black Background';
        }

        // Show troubleshooting info
        function showTroubleshootingInfo() {
            if (document.getElementById('troubleshooting')) return;
            
            const troubleshooting = document.createElement('div');
            troubleshooting.id = 'troubleshooting';
            troubleshooting.className = 'info';
            troubleshooting.style.backgroundColor = '#fff3cd';
            troubleshooting.innerHTML = `
                <h3>‚ö†Ô∏è Troubleshooting</h3>
                <p><strong>Please try the following:</strong></p>
                <ol>
                    <li><strong>Check browser permissions:</strong> Allow this website to access your camera</li>
                    <li><strong>Use HTTPS or localhost:</strong>
                        <ul>
                            <li>If using local file (file:///), use a local server instead</li>
                            <li>Recommended: Python's <code>python -m http.server 8000</code></li>
                            <li>Or use online editors like CodePen or JSFiddle</li>
                        </ul>
                    </li>
                    <li><strong>Check camera:</strong> Ensure camera is connected and not used by other apps</li>
                    <li><strong>Browser recommendation:</strong> Use latest Chrome, Edge, or Firefox</li>
                    <li><strong>Reload page:</strong> Press F5 and allow camera access again</li>
                </ol>
                <button onclick="location.reload()" style="margin-top: 10px;">üîÑ Reload Page</button>
            `;
            document.body.appendChild(troubleshooting);
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            statusDiv.textContent = '‚úì Ready. Click "Start Camera" to begin.';
            statusDiv.className = 'status ready';
        });
    </script>
</body>
</html>
